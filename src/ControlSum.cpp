#include <Arduino.h>
#include "ControlSum.h"

// uint8_t crc8(const uint8_t *data, size_t len)
// {                     // Функция для вычисления контрольной суммы
//   uint8_t crc = 0x00; // вычисление контрольной суммы принято начинать с того, что ей присваивается значение 0
//   while (len--)
//   {                            // len-длинна значения, что будет отправлятся. Тут перебирается каждый его байт
//     uint8_t extract = *data++; // data-размер значения, что будет отправлятся. ++: одновременно сдвигаем указатель к следующему элементу. extract сохраняет в себе текущий байт
//     for (uint8_t tempI = 8; tempI; tempI--)
//     {                                       // 1 байт = 8 бит. Проходимся по каждому биту
//       uint8_t sum = (crc ^ extract) & 0x01; // crc ^ extract выполняет побитовое исключающее ИЛИ (XOR) между текущим значением CRC и текущим байтом (extract).
//                                             // Затем с помощью & 0x01 мы берём только младший бит результата (то есть проверяем, является ли четным или нечетным суммарное значение).
//                                             // Переменная sum получает значение 0 или 1 в зависимости от результата этой операции.
//       crc >>= 1;                            // Сдвигаем значение CRC вправо на 1 бит. Это подготовка к следующей итерации обработки текущего бита.
//       if (sum)                              // Если значение sum равно 1 (т.е. младший бит был установлен), то выполняется XOR текущего crc с полиномиальным коэффициентом 0x8C.
//         crc ^= 0x8C;                        // – Этот коэффициент — характерный для выбранного алгоритма CRC-8. Он задаёт полином, по которому и ведётся вычисление контрольной суммы.
//       extract >>= 1;                        // Сдвигаем извлечённый байт вправо на 1 бит, чтобы на следующей итерации обработать следующий бит текущего байта.
//     }
//   }
//   return crc; // возвращение контрольной суммы
// }
uint16_t crc16(const uint8_t *data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i = 0; i < len; i++) {
    crc ^= data[i];
    for (uint8_t j = 0; j < 8; j++) {
      if (crc & 0x0001)
        crc = (crc >> 1) ^ 0xA001;
      else
        crc >>= 1;
    }
  }
  return crc;
}
